
# 数据结构和算法

### 1. 为什么学习算法
  1.1 写好程序提高效率  
  1.2 开拓视野增加知识储备  
  1.3 数据可视化，VR，游戏，AI和现在不知道的Anything...   

### 2. 数量级，输入，输出
  2.0 在写算法之前，对数据的应用场景和数据规模全面了解  
  2.1 数量级: 万级，亿级...  
  2.2 算法是输入到输出的映射  
  2.3 淘宝统计订单的算法应该支持【十亿】级数据，在【毫秒】级时间内完成计算  
  2.4 知乎统计用户肖像的算法应该支持【亿】级数据，在【小时】级时间内完成一次统计  
  2.5 React的VirtualDOM应该支持【万】级数据，在【毫秒】级时间内完成一次计算（显示器60HZ，16.7毫秒刷新一次）  

### 3. 二分查找
  3.1 二分法的效率  
      关键问题：最坏的情况从1000个学生【有序排列】里面找到目标学生，递归需要1000次，二分法(1000/500/250...)需要10次，速度提升近100倍..
  3.2 算法抽象  
```ts
function bsearch(A, x)
A: 有序数组
x: 需要查找的值
返回: x在A中的位置，不存在，返回-1
```
  3.3 算法实现  
      循环不变式: l-查找范围左，r-查找范围右  
```ts
function bsearch(A,x){
  let l=0,r=A.length-1,guess;
  while(l<=r){
    guess=Math.floor((l+r)/2)
    // 循环不变式: l-查找范围左，r-查找范围右
    // guess等于l，r的中间位置
    if (A[guess]===x) {
      return guess
    } else if(A[guess]>x) {
      // 查找范围在左
      r=guess-1
    } else {
      // 查找范围在右
      l=guess+1
    }
    // 循环不变式: l-新查找范围左，r-新查找范围右
  }
  return -1
}
```
  4.3 时间复杂度  O(lgn)  
      O(lgN)

### 4. 插入排序
  4.1 关键问题：如何在一个有序数组中插入一个新值，或者排序问题  
  4.2 算法抽象  
```ts
function insert(A,x)
A: 已排序数组
x: 需要插入的值
返回: 无
```
  4.3 算法实现  
      insert函数的循环不变式: p只想下一个要比较的元素，p+1指向腾出来的空位  
      插入排序 insertion_sort函数的循环不变式: i指向下一个需要排序的元素  
```ts
function insert(A,i,x) {
  let p = i-1
  while(p>=0 && A[p]>x) {
    // 交换位置
    A[p+1] = A[p]
    p--
  }
  // 插值
  A[p+1] = x
}
function insertion_sort(A) {
  for(let i=0,l=A.length;i<l;i++){
    insert(A, i, A[i])
  }
}
```
  4.3 时间复杂度  O(n^2)  
      主循环执行 N-1 次  
      insert函数的 while循环执行时间不固定，最坏的情况为 T(n) = (N^2)/2 - (N/2), N=10000的情况，结合现在cpu主频在4G左右(10亿)，大概需要1s的样子，还是比较慢的  

### 5. 冒泡排序  
  5.1 关键问题：排序问题  
  5.2 算法抽象
```ts
function bubble_sort(A)
A: 需要排序的数组
返回: 无
```
  5.3 算法实现
      外层循环不变式：外层循环（从大到小）控制当前已排序的次数，内层循环控（从小到大）制当前外层循环次数的各值比较和转换  
```ts
function swap(A,b,s){
  const t = b
  A[b] = A[s]
  A[s] = b
}
function bubble_sort(A){
  for(let i=A.length-1;i>=1;i--){
    for(let j=0;j<=i;j++){
      A[j] > A[j+1] && swap(A,j,j+1)
    }
  }
}
```
  5.4 时间复杂度  O(n^2)  
      外循环执行i次，内循环执行N-1次  
      最坏的情况为 T(n) = (N^2)/2 - (N/2)  

### 6. 合并排序（未完成）  
  5.1 关键问题：如何合并两个有序数组  
  5.2 算法抽象
```ts
function merge(A,p,q,r)
A: 数组
p: 左半边开始位置
q: 左半边结束，右半边开始位置
r: 右半边结束位置
```
  5.3 算法实现
```ts
```
  5.4 时间复杂度  O(nlgn)  

### 6. 递归（未完成）  
  5.1 关键问题：如何合并两个有序数组  
  5.2 算法抽象
```ts
function
```
  5.3 算法实现
```ts
```
  5.4 时间复杂度  O(nlgn)  

### 7. 排序算法概述  
  7.0 概述
```ts
O(n^2): 插入排序，比较排序，冒泡排序    ---> 基于比较
O(nlgn): 合并排序，快速排序，分块排序   ---> 基于比较
O(n)/O(nk): 桶排序，基数排序          ---> 其他


